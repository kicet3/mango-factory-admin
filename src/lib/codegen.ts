/**
 * Craft.js JSON → React TSX Code Generator
 *
 * Craft.js 에디터의 serialize() 결과를 실제 React 코드로 변환
 */

type CraftNodeMap = {
  [id: string]: {
    type: { resolvedName: string };
    props: Record<string, any>;
    nodes: string[];
    parent?: string;
  };
};

type TreeNode = {
  name: string;
  props: Record<string, any>;
  children: TreeNode[];
};

/**
 * Craft.js JSON을 트리 구조로 변환
 */
function buildTree(rootId: string, nodes: CraftNodeMap): TreeNode {
  const node = nodes[rootId];

  if (!node) {
    throw new Error(`Node with id ${rootId} not found`);
  }

  const children = (node.nodes || []).map((childId) =>
    buildTree(childId, nodes)
  );

  return {
    name: node.type.resolvedName,
    props: node.props || {},
    children,
  };
}

/**
 * Props 객체를 JSX 문자열로 변환
 */
function propsToJsx(props: Record<string, any>): string {
  const entries = Object.entries(props);
  if (!entries.length) return "";

  return (
    " " +
    entries
      .map(([key, value]) => {
        // 문자열
        if (typeof value === "string") {
          return `${key}="${value}"`;
        }
        // 숫자, boolean
        if (typeof value === "number" || typeof value === "boolean") {
          return `${key}={${value}}`;
        }
        // 객체/배열은 JSON.stringify
        if (typeof value === "object" && value !== null) {
          return `${key}={${JSON.stringify(value)}}`;
        }
        // 기타 (함수 등)
        return `${key}={${String(value)}}`;
      })
      .join(" ")
  );
}

/**
 * TreeNode를 JSX 문자열로 재귀 렌더링
 */
function renderNode(node: TreeNode, indentLevel = 2): string {
  const indent = " ".repeat(indentLevel);
  const propsStr = propsToJsx(node.props);

  // 자식 없으면 self-closing
  if (node.children.length === 0) {
    return `${indent}<${node.name}${propsStr} />\n`;
  }

  // 자식 있으면 재귀 렌더링
  const childrenStr = node.children
    .map((child) => renderNode(child, indentLevel + 2))
    .join("");

  return `${indent}<${node.name}${propsStr}>\n${childrenStr}${indent}</${node.name}>\n`;
}

/**
 * 최종 React 컴포넌트 코드 생성
 */
export function generateComponentCode(
  rootId: string,
  nodes: CraftNodeMap,
  componentName = "GeneratedPage"
): string {
  const tree = buildTree(rootId, nodes);
  const body = renderNode(tree, 2);

  // 사용된 컴포넌트 목록 추출
  const usedComponents = new Set<string>();

  function collectComponents(node: TreeNode) {
    usedComponents.add(node.name);
    node.children.forEach(collectComponents);
  }

  collectComponents(tree);

  // import 문 생성
  const componentList = Array.from(usedComponents)
    .filter(name => name !== 'Container') // 기본 컴포넌트 제외
    .join(', ');

  const imports = componentList
    ? `import { ${componentList} } from "@/components/craft";\n`
    : '';

  return `import React from "react";
${imports}
/**
 * AUTO-GENERATED by Craft.js Editor
 * 이 파일은 자동 생성되었습니다. 직접 수정하지 마세요.
 */
export const ${componentName}: React.FC = () => {
  return (
${body}  );
};
`;
}

/**
 * Craft.js serialize() 결과를 React 코드로 변환
 */
export function craftToReactCode(
  serializedJson: string,
  componentName = "GeneratedPage"
): string {
  try {
    const nodes: CraftNodeMap = JSON.parse(serializedJson);
    return generateComponentCode("ROOT", nodes, componentName);
  } catch (error) {
    console.error("Code generation error:", error);
    throw new Error(`Failed to generate React code: ${error}`);
  }
}

/**
 * 코드를 파일로 다운로드할 수 있는 Blob 생성
 */
export function createCodeBlob(code: string): Blob {
  return new Blob([code], { type: "text/plain;charset=utf-8" });
}
